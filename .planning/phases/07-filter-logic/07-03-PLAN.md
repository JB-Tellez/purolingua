---
phase: 07-filter-logic
plan: 03
type: execute
wave: 2
depends_on: [07-01]
files_modified:
  - src/js/core/app.js
  - src/js/utils/deck-utils.js
  - src/js/features/progress.js
autonomous: true
requirements: [FLTR-03, FLTR-04, FLTR-05, FLTR-06, FLTR-07, FLTR-08]

must_haves:
  truths:
    - "New user (empty localStorage) gets activeLevels defaulted to ['A1'] on app init"
    - "Returning user (progress in localStorage) gets activeLevels defaulted to ['A1','A2'] on app init"
    - "If a saved level-filter preference exists in localStorage, that value is restored regardless of user type"
    - "switchLanguage() re-initializes the level filter for the new locale — no bleed-through from previous language"
    - "getDueCount(deck, activeLevels) counts only cards whose level is in the activeLevels array AND are SRS-due"
    - "startDeck() builds its due-index list using the same level filter as getDueCount — badge and session always match"
    - "generateChoices(correctCard, filteredCards) uses the pre-filtered card array; no cross-level foils appear"
  artifacts:
    - path: "src/js/core/app.js"
      provides: "initActiveLevels(), updateActiveLevels(), wired initializeApp() and switchLanguage()"
      contains: "initActiveLevels"
    - path: "src/js/features/progress.js"
      provides: "updated getDueCount(deck, activeLevels) signature"
      contains: "function getDueCount(deck, activeLevels)"
    - path: "src/js/utils/deck-utils.js"
      provides: "updated generateChoices(correctCard, filteredCards) signature"
      contains: "function generateChoices(correctCard, filteredCards)"
  key_links:
    - from: "src/js/core/app.js"
      to: "src/js/core/state.js"
      via: "getActiveLevels/setActiveLevels imported and used in initActiveLevels, renderDecks, startDeck, renderCard"
      pattern: "getActiveLevels|setActiveLevels"
    - from: "src/js/core/app.js"
      to: "src/js/features/progress.js"
      via: "loadLevelFilter/saveLevelFilter/hasProgressData/getDueCount imported"
      pattern: "loadLevelFilter|hasProgressData"
    - from: "src/js/core/app.js"
      to: "src/js/utils/deck-utils.js"
      via: "generateChoices called with pre-filtered card array"
      pattern: "generateChoices.*filteredCards"
---

<objective>
Wire the level filter through all three active call sites: (1) app initialization + language switch (new/returning user defaults + persistence), (2) getDueCount and startDeck (count parity, FLTR-07), and (3) generateChoices distractor pool (FLTR-08).

Purpose: After this plan, the filter logic is fully operational — the app starts with the right level filter, persists it, and every card-facing function respects it. Phase 8 only needs to add UI chips that call the already-wired updateActiveLevels().
Output: Modified app.js, progress.js (getDueCount signature), deck-utils.js (generateChoices signature).
</objective>

<execution_context>
@./.claude/get-shit-done/workflows/execute-plan.md
@./.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/phases/07-filter-logic/07-RESEARCH.md
@.planning/phases/07-filter-logic/07-01-SUMMARY.md
@src/js/core/app.js
@src/js/core/state.js
@src/js/features/progress.js
@src/js/utils/deck-utils.js
</context>

<tasks>

<task type="auto">
  <name>Task 1: Update getDueCount signature and generateChoices signature</name>
  <files>src/js/features/progress.js, src/js/utils/deck-utils.js</files>
  <action>
**progress.js — update getDueCount:**

Change `function getDueCount(deck)` to `function getDueCount(deck, activeLevels)`. Add the level filter check inside the forEach loop:

```js
function getDueCount(deck, activeLevels) {
    let count = 0;
    deck.cards.forEach((card, index) => {
        if (activeLevels.includes(card.level) && isCardDue(deck.id, index)) {
            count++;
        }
    });
    return count;
}
```

The export for `getDueCount` is unchanged. This is a backwards-incompatible signature change — the ONLY caller is `app.js` (the research confirmed this). app.js will be updated in Task 2.

**deck-utils.js — update generateChoices:**

Change `function generateChoices(correctCard, deck)` to `function generateChoices(correctCard, filteredCards)`. Replace `deck.cards.filter(...)` with `filteredCards.filter(...)`:

```js
function generateChoices(correctCard, filteredCards) {
    // filteredCards is already the level-filtered subset of deck.cards
    const potentialFoils = filteredCards.filter(c => c.back !== correctCard.back);
    const shuffledFoils = potentialFoils.sort(() => 0.5 - Math.random());
    const foils = shuffledFoils.slice(0, 3);
    const choices = [
        { text: correctCard.back, isCorrect: true },
        ...foils.map(f => ({ text: f.back, isCorrect: false }))
    ];
    return choices.sort(() => 0.5 - Math.random());
}
```

The export for `generateChoices` is unchanged. The existing test in `tests/deck-utils.test.js` calls `generateChoices(card, mockDeck)` — this will BREAK because the second argument is now expected to be a cards array, not a deck object. Update `tests/deck-utils.test.js` to pass `mockDeck.cards` instead of `mockDeck` in all four test calls. This keeps the existing tests valid with the new signature.
  </action>
  <verify>
Grep progress.js: `function getDueCount(deck, activeLevels)` exists and body contains `activeLevels.includes(card.level)`.
Grep deck-utils.js: `function generateChoices(correctCard, filteredCards)` exists and body contains `filteredCards.filter`.
Grep tests/deck-utils.test.js: no remaining calls to `generateChoices(card, mockDeck)` — all should be `generateChoices(card, mockDeck.cards)`.
Run: `bun run test` — deck-utils.test.js must still pass.
  </verify>
  <done>
getDueCount(deck, activeLevels) filters by level AND SRS due date. generateChoices(correctCard, filteredCards) uses the filteredCards array for foils. tests/deck-utils.test.js updated to pass mockDeck.cards. All existing tests pass.
  </done>
</task>

<task type="auto">
  <name>Task 2: Wire app.js — init, switchLanguage, renderDecks, startDeck, renderCard</name>
  <files>src/js/core/app.js</files>
  <action>
Make the following changes to app.js, in order:

**1. Update imports:**

Add `getActiveLevels`, `setActiveLevels` to the import from `./state.js`.
Add `loadLevelFilter`, `saveLevelFilter`, `hasProgressData` to the import from `../features/progress.js`.

**2. Add `updateActiveLevels()` helper function** (after the DOM constant declarations, before `initializeI18n`):

```js
// Coordinator: updates state and persists. Called by initActiveLevels and (Phase 8) chip click handlers.
function updateActiveLevels(levels) {
    setActiveLevels(levels);           // enforces FLTR-06 guard internally
    saveLevelFilter(getActiveLevels()); // persist after guard (getActiveLevels returns current value)
}
```

Note: call `saveLevelFilter(getActiveLevels())` not `saveLevelFilter(levels)` — this ensures we persist the post-guard value (e.g., if levels was empty and got no-op'd, we persist the unchanged value).

**3. Add `initActiveLevels()` function** (immediately after `updateActiveLevels`):

```js
function initActiveLevels() {
    const saved = loadLevelFilter();
    if (saved !== null) {
        setActiveLevels(saved); // restore saved preference (FLTR-05); no need to re-save
        return;
    }
    // No saved preference — apply new/returning user default (FLTR-03, FLTR-04)
    const defaultLevels = hasProgressData() ? ['A1', 'A2'] : ['A1'];
    updateActiveLevels(defaultLevels); // sets state + saves for next load
}
```

**4. Update `initializeApp()`** — insert `initActiveLevels()` between `loadProgress()` and `renderDecks()`:

```js
loadProgress();
initActiveLevels();  // NEW — must come after loadProgress (hasProgressData needs it)
renderDecks();
```

**5. Update `switchLanguage(localeCode)`** — insert `initActiveLevels()` between `loadProgress()` and `initializeI18n()` (to match the same ordering as initializeApp):

```js
setLocale(localeCode);
loadProgress();
initActiveLevels();  // NEW — re-derive filter for new locale (Pitfall 3/6 prevention)
initializeI18n();
updateLanguageSelectorUI();
renderDecks();
document.getElementById('language-dropdown').classList.add('hidden');
```

**6. Update `renderDecks()`** — pass `getActiveLevels()` to `getDueCount`:

```js
const dueCount = getDueCount(deck, getActiveLevels());
```

**7. Update `startDeck(deck)`** — add level filter to the `tempDueIndices` loop:

```js
const levels = getActiveLevels();
deck.cards.forEach((card, index) => {
    if (levels.includes(card.level) && isCardDue(deck.id, index)) {
        tempDueIndices.push(index);
    }
});
```

**8. Update `renderCard()`** — build a filtered card array and pass it to `generateChoices`:

```js
const activeLevels = getActiveLevels();
const filteredCards = getCurrentDeck().cards.filter(c => activeLevels.includes(c.level));
const choices = generateChoices(card, filteredCards);
```

Replace the existing `const choices = generateChoices(card, getCurrentDeck());` with these three lines.

No other changes to app.js. `updateActiveLevels` is exported only as a module-level function for future Phase 8 chip click handlers — do NOT export it yet (Phase 8 wires the UI).
  </action>
  <verify>
Grep app.js:
- `initActiveLevels` called in both `initializeApp` and `switchLanguage`
- `getDueCount(deck, getActiveLevels())` in renderDecks
- `levels.includes(card.level) && isCardDue` in startDeck
- `filteredCards = getCurrentDeck().cards.filter(c => activeLevels.includes(c.level))` in renderCard
- `generateChoices(card, filteredCards)` in renderCard

Run: `bun run test` — all tests pass.
  </verify>
  <done>
app.js wired: initActiveLevels() runs at init and on language switch, getDueCount receives activeLevels, startDeck filters by level, generateChoices receives pre-filtered cards. Filter logic is fully operational.
  </done>
</task>

</tasks>

<verification>
Run: `bun run test`
All tests must pass — including updated deck-utils.test.js. Zero failures.

Manual smoke-check (optional but recommended): `bun run dev`, open app in browser, verify deck due-count badges show. Switch language — badges should re-render.
</verification>

<success_criteria>
- getDueCount(deck, activeLevels) is the only form used — no unfiltered call sites remain
- startDeck() and getDueCount() use identical card-level predicate (activeLevels.includes(card.level)) — count parity guaranteed
- generateChoices() receives filteredCards — no cross-level foil contamination
- initActiveLevels() wired into initializeApp() and switchLanguage() in correct order (after loadProgress, before renderDecks)
- All tests pass
</success_criteria>

<output>
After completion, create `.planning/phases/07-filter-logic/07-03-SUMMARY.md` following the summary template.
</output>
