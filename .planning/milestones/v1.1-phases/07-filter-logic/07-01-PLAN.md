---
phase: 07-filter-logic
plan: 01
type: execute
wave: 1
depends_on: []
files_modified:
  - src/js/core/state.js
  - src/js/features/progress.js
autonomous: true
requirements: [FLTR-02, FLTR-03, FLTR-04, FLTR-05, FLTR-06]

must_haves:
  truths:
    - "getActiveLevels() returns the current active levels array (never empty)"
    - "setActiveLevels([]) and setActiveLevels(null) are silent no-ops — state unchanged"
    - "setActiveLevels(['A1', 'A2']) updates state to ['A1', 'A2'] and returns a copy (not a reference)"
    - "loadLevelFilter() returns null when no localStorage key exists for the current locale"
    - "saveLevelFilter(['A1']) round-trips: loadLevelFilter() returns ['A1'] after save"
    - "hasProgressData() returns false when progress object is empty; true when it has at least one key"
  artifacts:
    - path: "src/js/core/state.js"
      provides: "activeLevels state variable with getActiveLevels/setActiveLevels exports"
      contains: "activeLevels"
    - path: "src/js/features/progress.js"
      provides: "loadLevelFilter, saveLevelFilter, hasProgressData exports"
      contains: "loadLevelFilter"
  key_links:
    - from: "src/js/core/state.js"
      to: "src/js/core/app.js"
      via: "getActiveLevels/setActiveLevels exports consumed by initActiveLevels()"
      pattern: "export.*getActiveLevels"
    - from: "src/js/features/progress.js"
      to: "src/js/core/app.js"
      via: "loadLevelFilter/saveLevelFilter/hasProgressData exports consumed by initActiveLevels()"
      pattern: "export.*loadLevelFilter"
---

<objective>
Add the activeLevels state variable to state.js and the level-filter persistence helpers to progress.js. This is the foundation layer for Phase 7 — all other plans depend on these exports.

Purpose: Establish a single source of truth for the active level filter (state.js) and the localStorage load/save/detection helpers (progress.js) before any call-site wiring happens.
Output: Four new exported functions (getActiveLevels, setActiveLevels, loadLevelFilter, saveLevelFilter, hasProgressData) ready to be consumed by app.js.
</objective>

<execution_context>
@./.claude/get-shit-done/workflows/execute-plan.md
@./.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/phases/07-filter-logic/07-RESEARCH.md
@src/js/core/state.js
@src/js/features/progress.js
</context>

<tasks>

<task type="auto">
  <name>Task 1: Add activeLevels state to state.js</name>
  <files>src/js/core/state.js</files>
  <action>
Add a module-level `activeLevels` variable and its getter/setter below the existing `isQuizAnswered` variable (line 7). Default value is `['A1']` — this gets overwritten by `initActiveLevels()` at app init before any render happens.

Add these lines after the existing state variable declarations (after `let isQuizAnswered = false;`):

```js
let activeLevels = ['A1']; // default; overwritten by initActiveLevels() at app init
```

Add these two functions in the Getters section (after `getIsQuizAnswered`):

```js
function getActiveLevels() {
    return [...activeLevels]; // return copy to prevent external mutation (Pitfall 5)
}
```

Add this function in the Setters section (after `setIsQuizAnswered`):

```js
function setActiveLevels(levels) {
    if (!levels || levels.length === 0) return; // FLTR-06: silent no-op on empty/null
    activeLevels = [...levels]; // store copy
}
```

Update the `resetDeckState()` function to NOT reset activeLevels — levels persist through deck navigation. (Do not add activeLevels to resetDeckState.)

Add `getActiveLevels` and `setActiveLevels` to the export block alongside existing exports.

Do NOT import anything from progress.js into state.js — that would create a circular dependency (progress.js imports i18n.js; keeping state.js dependency-free is the existing pattern). The save-on-set pattern is handled by a coordinator in app.js (see Plan 03), not inside setActiveLevels.
  </action>
  <verify>
Grep state.js for `getActiveLevels` and `setActiveLevels` in the export block. Confirm `activeLevels = ['A1']` default exists. Confirm setter has the `!levels || levels.length === 0` guard. Confirm `return [...activeLevels]` in getter.
  </verify>
  <done>
state.js exports getActiveLevels and setActiveLevels. setActiveLevels([]) is a no-op. getActiveLevels() returns a copy. Default is ['A1'].
  </done>
</task>

<task type="auto">
  <name>Task 2: Add level-filter persistence helpers to progress.js</name>
  <files>src/js/features/progress.js</files>
  <action>
Add three new functions to progress.js. Insert them after the `getStorageKey()` function (after line 9) so they are grouped with persistence utilities.

**getLevelFilterKey()** (private helper, not exported):
```js
function getLevelFilterKey() {
    return `${getLocale()}-level-filter`;
}
```

**loadLevelFilter()** (exported): Reads from localStorage. Returns the parsed array if valid, or `null` if not set or invalid. Returning `null` (not a default) is critical — the caller (`initActiveLevels()` in app.js) decides the default based on user type.
```js
function loadLevelFilter() {
    try {
        const saved = localStorage.getItem(getLevelFilterKey());
        if (saved) {
            const parsed = JSON.parse(saved);
            if (Array.isArray(parsed) && parsed.length > 0) {
                return parsed;
            }
        }
    } catch (e) {
        console.warn('Failed to load level filter from localStorage:', e);
    }
    return null; // null = no saved preference; caller decides default
}
```

**saveLevelFilter(levels)** (exported): Writes the array to localStorage. Called by `updateActiveLevels()` in app.js after `setActiveLevels()` succeeds.
```js
function saveLevelFilter(levels) {
    try {
        localStorage.setItem(getLevelFilterKey(), JSON.stringify(levels));
    } catch (e) {
        console.warn('Failed to save level filter to localStorage:', e);
    }
}
```

**hasProgressData()** (exported): Inspects the module-level `progress` variable. Valid ONLY after `loadProgress()` has been called. Returns true if at least one key exists (returning user), false if empty (new user).
```js
function hasProgressData() {
    return Object.keys(progress).length > 0;
}
```

Update the export block to add: `loadLevelFilter`, `saveLevelFilter`, `hasProgressData`.

Do NOT export `getLevelFilterKey` — it is an internal helper.

Existing function `getDueCount(deck)` signature stays unchanged in this plan. It will be updated in Plan 03 to accept `activeLevels`.
  </action>
  <verify>
Grep progress.js for `loadLevelFilter`, `saveLevelFilter`, `hasProgressData` in the export block. Confirm `loadLevelFilter` returns `null` when nothing saved. Confirm `getLevelFilterKey` uses `${getLocale()}-level-filter` pattern. Confirm `hasProgressData` inspects `Object.keys(progress).length`.
  </verify>
  <done>
progress.js exports loadLevelFilter (returns null when no saved pref), saveLevelFilter (writes to locale-scoped key), and hasProgressData (inspects module-level progress object). getDueCount signature is unchanged.
  </done>
</task>

</tasks>

<verification>
After both tasks, run: `bun run test` — all existing tests must still pass (no regressions). The new functions are not yet exercised by tests (that is Plan 02's job).

Confirm export blocks:
- state.js: `getActiveLevels`, `setActiveLevels` present in export statement
- progress.js: `loadLevelFilter`, `saveLevelFilter`, `hasProgressData` present in export statement
</verification>

<success_criteria>
- state.js has `activeLevels` variable with getter (returns copy) and setter (FLTR-06 guard)
- progress.js has `loadLevelFilter` (null on miss), `saveLevelFilter` (locale-scoped key), `hasProgressData` (inspects progress object)
- No circular dependencies introduced
- All existing tests pass
</success_criteria>

<output>
After completion, create `.planning/phases/07-filter-logic/07-01-SUMMARY.md` following the summary template.
</output>
